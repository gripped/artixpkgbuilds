diff --git a/rspec-core/Rakefile b/rspec-core/Rakefile
index 476a7c741..4d4f13aa1 100644
--- a/rspec-core/Rakefile
+++ b/rspec-core/Rakefile
@@ -8,9 +8,6 @@ require "yaml"
 
 require "rspec/core/rake_task"
 
-require "cucumber/rake/task"
-Cucumber::Rake::Task.new(:cucumber)
-
 desc "Run all examples"
 RSpec::Core::RakeTask.new(:spec) do |t|
   t.ruby_opts = %w[-w]
@@ -24,11 +21,6 @@ namespace :spec do
   end
 end
 
-desc 'Run RuboCop on the lib directory'
-task :rubocop do
-  sh 'bundle exec rubocop lib'
-end
-
 desc "delete generated files"
 task :clobber do
   sh 'find . -name "*.rbc" | xargs rm'
diff --git a/rspec-core/spec/integration/bisect_runners_spec.rb b/rspec-core/spec/integration/bisect_runners_spec.rb
deleted file mode 100644
index d1a233d2d..000000000
--- a/rspec-core/spec/integration/bisect_runners_spec.rb
+++ /dev/null
@@ -1,139 +0,0 @@
-require 'support/aruba_support'
-require 'rspec/core/bisect/shell_command'
-require 'rspec/core/bisect/shell_runner'
-require 'rspec/core/bisect/fork_runner'
-
-module RSpec::Core
-  RSpec.shared_examples_for "a bisect runner" do
-    include_context "aruba support"
-
-    let(:shell_command) { Bisect::ShellCommand.new([]) }
-
-    def with_runner(&block)
-      handle_current_dir_change do
-        cd '.' do
-          options = ConfigurationOptions.new(shell_command.original_cli_args)
-          runner = Runner.new(options)
-          output = StringIO.new
-          runner.configure(output, output)
-          described_class.start(shell_command, runner, &block)
-        end
-      end
-    end
-
-    it 'runs the specs in an isolated environment and reports the results' do
-      RSpec.configuration.formatter = 'progress'
-
-      write_file 'spec/a_spec.rb', "
-        formatters = RSpec.configuration.formatter_loader.formatters
-        if formatters.any? { |f| f.is_a?(RSpec::Core::Formatters::ProgressFormatter) }
-          raise 'Leaked progress formatter from host environment'
-        end
-
-        RSpec.describe 'A group' do
-          it('passes') { expect(1).to eq 1 }
-          it('fails')  { expect(1).to eq 2 }
-        end
-      "
-
-      with_runner do |runner|
-        expect(runner.original_results).to have_attributes(
-          :all_example_ids => %w[ ./spec/a_spec.rb[1:1] ./spec/a_spec.rb[1:2] ],
-          :failed_example_ids => %w[ ./spec/a_spec.rb[1:2] ]
-        )
-
-        expect(runner.run(%w[ ./spec/a_spec.rb[1:1] ])).to have_attributes(
-          :all_example_ids => %w[ ./spec/a_spec.rb[1:1] ],
-          :failed_example_ids => %w[]
-        )
-      end
-    end
-
-    it 'honors `run_all_when_everything_filtered`' do
-      write_file 'spec/a_spec.rb', "
-        RSpec.configure do |c|
-          c.filter_run :focus
-          c.run_all_when_everything_filtered = true
-        end
-
-        RSpec.describe 'A group' do
-          it('passes') { expect(1).to eq 1 }
-          it('fails')  { expect(1).to eq 2 }
-        end
-      "
-
-      with_runner do |runner|
-        expect(runner.original_results).to have_attributes(
-          :all_example_ids => %w[ ./spec/a_spec.rb[1:1] ./spec/a_spec.rb[1:2] ],
-          :failed_example_ids => %w[ ./spec/a_spec.rb[1:2] ]
-        )
-      end
-    end
-
-    it 'raises BisectFailedError with all run output when it encounters an error loading spec files' do
-      write_file 'spec/a_spec.rb', "
-        puts 'stdout in a_spec'
-        warn 'stderr in a_spec'
-
-        RSpec.escribe 'A group' do
-          it('passes') { expect(1).to eq 1 }
-          it('fails')  { expect(1).to eq 2 }
-        end
-      "
-
-      rspec_description =
-        if RUBY_VERSION.to_f > 3.2
-          "module RSpec"
-        else
-          "RSpec:Module"
-        end
-
-      with_runner do |runner|
-        expect {
-          runner.original_results
-        }.to raise_error(Bisect::BisectFailedError, a_string_including(
-          "undefined method #{quoted('escribe')} for #{rspec_description}",
-          'stdout in a_spec',
-          'stderr in a_spec'
-        ))
-      end
-    end
-  end
-
-  RSpec.describe Bisect::ShellRunner, :slow do
-    include_examples 'a bisect runner'
-  end
-
-  RSpec.describe Bisect::ForkRunner, :if => RSpec::Support::RubyFeatures.fork_supported? do
-    include_examples 'a bisect runner'
-
-    context 'when a `--require` option has been provided' do
-      let(:shell_command) { Bisect::ShellCommand.new(['--require', './spec/a_spec_helper']) }
-
-      it 'loads the specified file only once (rather than once per subset run)' do
-        write_file 'spec_helper_loads', ''
-        write_file 'spec/a_spec_helper.rb', "
-          File.open('spec_helper_loads', 'a') do |f|
-            f.print('.')
-          end
-        "
-
-        write_file 'spec/a_spec.rb', "
-          RSpec.describe 'A group' do
-            it('passes') { expect(1).to eq 1 }
-            it('fails')  { expect(1).to eq 2 }
-          end
-        "
-
-        with_runner do |runner|
-          runner.run(%w[ ./spec/a_spec.rb[1:1] ])
-          runner.run(%w[ ./spec/a_spec.rb[1:1] ])
-        end
-
-        cd '.' do
-          expect(File.read('spec_helper_loads')).to eq(".")
-        end
-      end
-    end
-  end
-end
diff --git a/rspec-core/spec/integration/fail_if_no_examples_spec.rb b/rspec-core/spec/integration/fail_if_no_examples_spec.rb
deleted file mode 100644
index 2cc4790bf..000000000
--- a/rspec-core/spec/integration/fail_if_no_examples_spec.rb
+++ /dev/null
@@ -1,107 +0,0 @@
-require 'support/aruba_support'
-
-RSpec.describe 'Fail if no examples' do
-  include_context "aruba support"
-
-  context 'when 1 passing example' do
-    def passing_example(fail_if_no_examples)
-      "
-        RSpec.configure { |c| c.fail_if_no_examples = #{fail_if_no_examples} }
-
-        RSpec.describe 'something' do
-          it 'succeeds' do
-            true
-          end
-        end
-      "
-    end
-
-    it 'succeeds if fail_if_no_examples set to true' do
-      write_file 'spec/example_spec.rb', passing_example(true)
-      run_command ""
-      expect(last_cmd_stdout).to include("1 example, 0 failures")
-      expect(last_cmd_exit_status).to eq(0)
-    end
-
-    it 'succeeds if fail_if_no_examples set to false' do
-      write_file 'spec/example_spec.rb', passing_example(false)
-      run_command ""
-      expect(last_cmd_stdout).to include("1 example, 0 failures")
-      expect(last_cmd_exit_status).to eq(0)
-    end
-  end
-
-  context 'when 1 failing example' do
-    def failing_example(fail_if_no_examples)
-      "
-        RSpec.configure { |c| c.fail_if_no_examples = #{fail_if_no_examples} }
-
-        RSpec.describe 'something' do
-          it 'fails' do
-            fail
-          end
-        end
-      "
-    end
-
-    it 'fails if fail_if_no_examples set to true' do
-      write_file 'spec/example_spec.rb', failing_example(true)
-      run_command ""
-      expect(last_cmd_stdout).to include("1 example, 1 failure")
-      expect(last_cmd_exit_status).to eq(1)
-    end
-
-    it 'fails if fail_if_no_examples set to false' do
-      write_file 'spec/example_spec.rb', failing_example(false)
-      run_command ""
-      expect(last_cmd_stdout).to include("1 example, 1 failure")
-      expect(last_cmd_exit_status).to eq(1)
-    end
-  end
-
-  context 'when 0 examples' do
-    def no_examples(fail_if_no_examples)
-      "
-        RSpec.configure { |c| c.fail_if_no_examples = #{fail_if_no_examples} }
-
-        RSpec.describe 'something' do
-        end
-      "
-    end
-
-    it 'fails if fail_if_no_examples set to true' do
-      write_file 'spec/example_spec.rb', no_examples(true)
-      run_command ""
-      expect(last_cmd_stdout).to include("0 examples, 0 failures")
-      expect(last_cmd_exit_status).to eq(1)
-    end
-
-    it 'succeeds if fail_if_no_examples set to false' do
-      write_file 'spec/example_spec.rb', no_examples(false)
-      run_command ""
-      expect(last_cmd_stdout).to include("0 examples, 0 failures")
-      expect(last_cmd_exit_status).to eq(0)
-    end
-
-    context 'when custom failure_exit_code set' do
-      def no_examples_custom_failure_exit_code(fail_if_no_examples)
-        "
-          RSpec.configure do |c|
-            c.fail_if_no_examples = #{fail_if_no_examples}
-            c.failure_exit_code = 15
-          end
-
-          RSpec.describe 'something' do
-          end
-        "
-      end
-
-      it 'fails if fail_if_no_examples set to true' do
-        write_file 'spec/example_spec.rb', no_examples_custom_failure_exit_code(true)
-        run_command ""
-        expect(last_cmd_stdout).to include("0 examples, 0 failures")
-        expect(last_cmd_exit_status).to eq(15)
-      end
-    end
-  end
-end
diff --git a/rspec-core/spec/integration/failed_line_detection_spec.rb b/rspec-core/spec/integration/failed_line_detection_spec.rb
deleted file mode 100644
index 7156b5401..000000000
--- a/rspec-core/spec/integration/failed_line_detection_spec.rb
+++ /dev/null
@@ -1,163 +0,0 @@
-require 'support/aruba_support'
-
-RSpec.describe 'Failed line detection' do
-  include_context "aruba support"
-
-  it "finds the source of a failure in a spec file that is defined at the current directory instead of in the normal `spec` subdir" do
-    write_file "the_spec.rb", "
-      RSpec.describe do
-        it 'fails via expect' do
-          expect(1).to eq(2)
-        end
-      end
-    "
-
-    run_command "the_spec.rb"
-    expect(last_cmd_stdout).to include("expect(1).to eq(2)")
-  end
-
-  it "finds the source of a failure in a spec file loaded by running `ruby file` rather than loaded directly by RSpec" do
-    write_file "passing_spec.rb", "
-      RSpec.describe do
-        example { }
-      end
-    "
-
-    write_file "failing_spec.rb", "
-      RSpec.describe do
-        it 'fails via expect' do
-          expect(1).to eq(2)
-        end
-      end
-    "
-
-    file = cd('.') { "#{Dir.pwd}/failing_spec.rb" }
-    load file
-    run_command "passing_spec.rb"
-
-    expect(last_cmd_stdout).to include("expect(1).to eq(2)")
-  end
-
-  it "finds the direct source of failure in any lib, app or spec file, and allows the user to configure what is considered a project source dir" do
-    write_file "lib/lib_mod.rb", "
-      module LibMod
-        def self.trigger_failure
-          raise 'LibMod failure'
-        end
-      end
-    "
-
-    write_file "app/app_mod.rb", "
-      module AppMod
-        def self.trigger_failure
-          raise 'AppMod failure'
-        end
-      end
-    "
-
-    write_file "spec/support/spec_support.rb", "
-      module SpecSupport
-        def self.trigger_failure
-          raise 'SpecSupport failure'
-        end
-      end
-    "
-
-    write_file "spec/default_config_spec.rb", "
-      require './lib/lib_mod'
-      require './spec/support/spec_support'
-      require './app/app_mod'
-
-      RSpec.describe do
-        example('1') { LibMod.trigger_failure }
-        example('2') { AppMod.trigger_failure }
-        example('3') { SpecSupport.trigger_failure }
-      end
-    "
-
-    run_command "./spec/default_config_spec.rb"
-
-    expect(
-      last_cmd_stdout
-    ).to include("raise 'LibMod failure'").
-                           and include("raise 'AppMod failure'").
-                           and include("raise 'SpecSupport failure'")
-
-    if RUBY_VERSION.to_f > 3.3
-      # Ruby 3.4 seems to print the calling function and we've not configured it otherwise
-      expect(last_cmd_stdout).to include("AppMod.trigger_failure")
-    end
-
-    write_file "spec/change_config_spec.rb", "
-      require './app/app_mod'
-
-      RSpec.configure do |c|
-        c.project_source_dirs = %w[ lib spec ]
-      end
-
-      RSpec.describe do
-        example('1') { AppMod.trigger_failure }
-      end
-    "
-
-    run_command "./spec/change_config_spec.rb"
-
-    expect(last_cmd_stdout).to include("AppMod.trigger_failure").
-                           and exclude("raise 'AppMod failure'")
-  end
-
-  it "finds the callsite of a method provided by a gem that fails (rather than the line in the gem)" do
-    write_file "vendor/gems/assertions/lib/assertions.rb", "
-      module Assertions
-        AssertionFailed = Class.new(StandardError)
-
-        def assert(value, msg)
-          raise(AssertionFailed, msg) unless value
-        end
-      end
-    "
-
-    write_file "spec/unit/the_spec.rb", "
-      require './vendor/gems/assertions/lib/assertions'
-
-      RSpec.describe do
-        include Assertions
-
-        it 'fails via assert' do
-          assert false, 'failed assertion'
-        end
-
-        it 'fails via expect' do
-          expect(1).to eq(2)
-        end
-      end
-    "
-
-    run_command ""
-
-    expect(last_cmd_stdout).to include("assert false, 'failed assertion'").
-                           and include("expect(1).to eq(2)").
-                           and exclude("raise(AssertionFailed, msg)")
-  end
-
-  it "falls back to finding a line in a gem when there are no backtrace lines in the app, lib or spec directories" do
-    write_file "vendor/gems/before_failure/lib/before_failure.rb", "
-      RSpec.configure do |c|
-        c.before { raise 'before failure!' }
-      end
-    "
-
-    write_file "spec/unit/the_spec.rb", "
-      require './vendor/gems/before_failure/lib/before_failure'
-
-      RSpec.describe do
-        example('1') { }
-      end
-    "
-
-    run_command ""
-
-    expect(last_cmd_stdout).to include("c.before { raise 'before failure!' }").
-                           and exclude("Unable to find matching line from backtrace")
-  end
-end
diff --git a/rspec-core/spec/integration/filtering_spec.rb b/rspec-core/spec/integration/filtering_spec.rb
deleted file mode 100644
index 7eb91af63..000000000
--- a/rspec-core/spec/integration/filtering_spec.rb
+++ /dev/null
@@ -1,318 +0,0 @@
-require 'support/aruba_support'
-
-RSpec.describe 'Filtering' do
-  include_context "aruba support"
-
-  it 'prints a rerun command for shared examples in external files that works to rerun' do
-    write_file "spec/support/shared_examples.rb", "
-      RSpec.shared_examples 'with a failing example' do
-        example { expect(1).to eq(2) } # failing
-        example { expect(2).to eq(2) } # passing
-      end
-    "
-
-    write_file "spec/host_group_spec.rb", "
-      load File.expand_path('../support/shared_examples.rb', __FILE__)
-
-      RSpec.describe 'A group with shared examples' do
-        include_examples 'with a failing example'
-      end
-
-      RSpec.describe 'A group with a passing example' do
-        example { expect(1).to eq(1) }
-      end
-    "
-
-    run_command ""
-    expect(last_cmd_stdout).to include("3 examples, 1 failure")
-    run_rerun_command_for_failing_spec
-    expect(last_cmd_stdout).to include("1 example, 1 failure")
-    # There was originally a bug when doing it again...
-    run_rerun_command_for_failing_spec
-    expect(last_cmd_stdout).to include("1 example, 1 failure")
-  end
-
-  def run_rerun_command_for_failing_spec
-    command = last_cmd_stdout[/Failed examples:\s+rspec (\S+) #/, 1]
-    run_command command
-  end
-
-  context "with a shared example containing a context in a separate file" do
-    it "runs the example nested inside the shared" do
-      write_file_formatted 'spec/shared_example.rb', "
-        RSpec.shared_examples_for 'a shared example' do
-          it 'succeeds' do
-          end
-
-          context 'with a nested context' do
-            it 'succeeds (nested)' do
-            end
-          end
-        end
-      "
-
-      write_file_formatted 'spec/simple_spec.rb', "
-        require File.join(File.dirname(__FILE__), 'shared_example.rb')
-
-        RSpec.describe 'top level' do
-          it_behaves_like 'a shared example'
-        end
-      "
-
-      run_command 'spec/simple_spec.rb:3 -fd'
-      expect(last_cmd_stdout).to match(/2 examples, 0 failures/)
-    end
-  end
-
-  context "passing a line-number filter" do
-    it "works with different custom runners used in the same process" do
-      result_counter = Class.new do
-        RSpec::Core::Formatters.register(self, :example_passed)
-
-        attr_accessor :passed_examples
-
-        def initialize(*)
-          @passed_examples = 0
-        end
-
-        def example_passed(notification)
-          @passed_examples += 1
-        end
-      end
-
-      spec_file = "spec/filtering_custom_runner_spec.rb"
-
-      write_file_formatted spec_file, "
-        RSpec.describe 'A group' do
-          example('ex 1') { }
-          example('ex 2') { }
-        end
-      "
-
-      spec_file_path = expand_path(spec_file)
-
-      formatter = result_counter.new
-      RSpec.configuration.add_formatter(formatter)
-      opts = RSpec::Core::ConfigurationOptions.new(["#{spec_file_path}[1:1]"])
-      RSpec::Core::Runner.new(opts).run(StringIO.new, StringIO.new)
-
-      expect(formatter.passed_examples).to eq 1
-
-      RSpec.clear_examples
-
-      formatter = result_counter.new
-      RSpec.configuration.add_formatter(formatter)
-      opts = RSpec::Core::ConfigurationOptions.new(["#{spec_file_path}[1:2]"])
-      RSpec::Core::Runner.new(opts).run(StringIO.new, StringIO.new)
-
-      expect(formatter.passed_examples).to eq 1
-    end
-
-    it "trumps exclusions, except for :if/:unless (which are absolute exclusions)" do
-      write_file_formatted 'spec/a_spec.rb', "
-        RSpec.configure do |c|
-          c.filter_run_excluding :slow
-        end
-
-        RSpec.describe 'A slow group', :slow do
-          example('ex 1') { }
-          example('ex 2') { }
-        end
-
-        RSpec.describe 'A group with a slow example' do
-          example('ex 3'              ) { }
-          example('ex 4', :slow       ) { }
-          example('ex 5', :if => false) { }
-        end
-      "
-
-      run_command "spec/a_spec.rb -fd"
-      expect(last_cmd_stdout).to include("1 example, 0 failures", "ex 3").and exclude("ex 1", "ex 2", "ex 4", "ex 5")
-
-      run_command "spec/a_spec.rb:5 -fd" # selecting 'A slow group'
-      expect(last_cmd_stdout).to include("2 examples, 0 failures", "ex 1", "ex 2").and exclude("ex 3", "ex 4", "ex 5")
-
-      run_command "spec/a_spec.rb:12 -fd" # selecting slow example
-      expect(last_cmd_stdout).to include("1 example, 0 failures", "ex 4").and exclude("ex 1", "ex 2", "ex 3", "ex 5")
-
-      run_command "spec/a_spec.rb:13 -fd" # selecting :if => false example
-      expect(last_cmd_stdout).to include("0 examples, 0 failures").and exclude("ex 1", "ex 2", "ex 3", "ex 4", "ex 5")
-    end
-
-    it 'works correctly when line numbers align with a shared example group line number from another file' do
-      write_file_formatted 'spec/support/shared_examples_with_matching_line.rb', "
-        # line 1
-        # line 2
-        # line 3
-        RSpec.shared_examples_for 'shared examples' do # line 4
-          it 'fails' do # line 5
-            fail 'shared example'
-          end
-        end
-      "
-
-      write_file_formatted 'spec/some_spec.rb', "
-        require File.expand_path('../support/shared_examples_with_matching_line', __FILE__) # line 1
-        RSpec.describe 'A group' do # line 2
-          it_behaves_like 'shared examples' # line 3
-          # line 4
-          it 'passes' do # line 5
-            expect(1).to eq(1)
-          end
-        end
-      "
-
-      run_command "spec/some_spec.rb:5"
-      expect(last_cmd_stdout).to include("1 example, 0 failures")
-    end
-  end
-
-  context "passing a line-number-filtered file and a non-filtered file" do
-    it "applies the line number filtering only to the filtered file, running all specs in the non-filtered file except excluded ones" do
-      write_file_formatted "spec/file_1_spec.rb", "
-        RSpec.describe 'File 1' do
-          it('passes') {      }
-          it('fails')  { fail }
-        end
-      "
-
-      write_file_formatted "spec/file_2_spec.rb", "
-        RSpec.configure do |c|
-          c.filter_run_excluding :exclude_me
-        end
-
-        RSpec.describe 'File 2' do
-          it('passes') { }
-          it('passes') { }
-          it('fails', :exclude_me) { fail }
-        end
-      "
-
-      run_command "spec/file_1_spec.rb:2 spec/file_2_spec.rb -fd"
-      expect(last_cmd_stdout).to match(/3 examples, 0 failures/)
-      expect(last_cmd_stdout).not_to match(/fails/)
-    end
-
-    it 'applies command line tag filters only to files that lack a line number filter' do
-      write_file_formatted "spec/file_1_spec.rb", "
-        RSpec.describe 'File 1' do
-          it('is selected by line')   { }
-          it('is not selected', :tag) { }
-        end
-      "
-
-      write_file_formatted "spec/file_2_spec.rb", "
-        RSpec.describe 'File 2' do
-          it('is not selected')          { }
-          it('is selected by tag', :tag) { }
-        end
-      "
-
-      run_command "spec/file_1_spec.rb:2 spec/file_2_spec.rb --tag tag -fd"
-      expect(last_cmd_stdout).to include(
-        "2 examples, 0 failures",
-        "is selected by line", "is selected by tag"
-      ).and exclude("not selected")
-    end
-  end
-
-  context "passing example ids at the command line" do
-    it "selects matching examples" do
-      write_file_formatted "spec/file_1_spec.rb", "
-        RSpec.describe 'File 1' do
-          1.upto(3) do |i|
-            example('ex ' + i.to_s) { expect(i).to be_odd }
-          end
-        end
-      "
-
-      write_file_formatted "spec/file_2_spec.rb", "
-        RSpec.describe 'File 2' do
-          1.upto(3) do |i|
-            example('ex ' + i.to_s) { expect(i).to be_even }
-          end
-        end
-      "
-
-      # Using the form that Metadata.relative_path returns...
-      run_command "./spec/file_1_spec.rb[1:1,1:3] ./spec/file_2_spec.rb[1:2]"
-      expect(last_cmd_stdout).to match(/3 examples, 0 failures/)
-
-      # Using spaces between scoped ids, and quoting the whole thing...
-      run_command "'./spec/file_1_spec.rb[1:1, 1:3]' ./spec/file_2_spec.rb[1:2]"
-      expect(last_cmd_stdout).to match(/3 examples, 0 failures/)
-
-      # Without the leading `.`...
-      run_command "spec/file_1_spec.rb[1:1,1:3] spec/file_2_spec.rb[1:2]"
-      expect(last_cmd_stdout).to match(/3 examples, 0 failures/)
-
-      # Using absolute paths...
-      spec_root = cd('.') { File.expand_path("spec") }
-      run_command "#{spec_root}/file_1_spec.rb[1:1,1:3] #{spec_root}/file_2_spec.rb[1:2]"
-      expect(last_cmd_stdout).to match(/3 examples, 0 failures/)
-    end
-
-    it "selects matching example groups" do
-      write_file_formatted "spec/file_1_spec.rb", "
-        RSpec.describe 'Group 1' do
-          example { fail }
-
-          context 'nested 1' do
-            it { }
-            it { }
-          end
-
-          context 'nested 2' do
-            example { fail }
-          end
-        end
-      "
-
-      run_command "./spec/file_1_spec.rb[1:2]"
-      expect(last_cmd_stdout).to match(/2 examples, 0 failures/)
-    end
-  end
-
-  context "with `filter_run_when_matching`" do
-    it "filters to matching examples" do
-      write_file_formatted "spec/example_spec.rb", "
-        RSpec.configure do |c|
-          c.filter_run_when_matching :some_tag
-        end
-
-        RSpec.describe 'A matching group', :some_tag do
-          it 'passes' do
-          end
-        end
-
-        RSpec.describe 'An unmatching group' do
-          it 'passes', :some_tag do
-          end
-
-          it 'fails' do
-            raise 'boom'
-          end
-        end
-      "
-
-      run_command ""
-      expect(last_cmd_stdout).to include("2 examples, 0 failures")
-    end
-
-    it "is ignored when no examples match the provided filter" do
-      write_file_formatted "spec/example_spec.rb", "
-        RSpec.configure do |c|
-          c.filter_run_when_matching :some_tag
-        end
-
-        RSpec.describe 'A group' do
-          it 'is still run' do
-          end
-        end
-      "
-
-      run_command ""
-      expect(last_cmd_stdout).to include("1 example, 0 failures")
-    end
-  end
-end
diff --git a/rspec-core/spec/integration/order_spec.rb b/rspec-core/spec/integration/order_spec.rb
deleted file mode 100644
index fa679533c..000000000
--- a/rspec-core/spec/integration/order_spec.rb
+++ /dev/null
@@ -1,217 +0,0 @@
-require 'support/aruba_support'
-
-RSpec.describe 'command line' do
-  include_context "aruba support"
-
-  before(:all) { setup_aruba }
-
-  before :all do
-    write_file 'spec/simple_spec.rb', "
-      RSpec.describe 'group 1' do
-        specify('group 1 example 1') {}
-        specify('group 1 example 2') {}
-        specify('group 1 example 3') {}
-        describe 'group 1-1' do
-          specify('group 1-1 example 1') {}
-          specify('group 1-1 example 2') {}
-          specify('group 1-1 example 3') {}
-        end
-      end
-    "
-
-    write_file 'spec/simple_spec2.rb', "
-      RSpec.describe 'group 2' do
-        specify('group 2 example 1') {}
-        specify('group 2 example 2') {}
-        specify('group 2 example 3') {}
-        describe 'group 2-1' do
-          specify('group 2-1 example 1') {}
-          specify('group 2-1 example 2') {}
-          specify('group 2-1 example 3') {}
-        end
-      end
-    "
-
-    write_file 'spec/order_spec.rb', "
-      RSpec.describe 'group 1' do
-        specify('group 1 example 1')  {}
-        specify('group 1 example 2')  {}
-        specify('group 1 example 3')  {}
-        specify('group 1 example 4')  {}
-        specify('group 1 example 5')  {}
-        specify('group 1 example 6')  {}
-        specify('group 1 example 7')  {}
-        specify('group 1 example 8')  {}
-        specify('group 1 example 9')  {}
-        specify('group 1 example 10') {}
-
-        describe 'group 1-1' do
-          specify('group 1-1 example 1')  {}
-          specify('group 1-1 example 2')  {}
-          specify('group 1-1 example 3')  {}
-          specify('group 1-1 example 4')  {}
-          specify('group 1-1 example 5')  {}
-          specify('group 1-1 example 6')  {}
-          specify('group 1-1 example 7')  {}
-          specify('group 1-1 example 8')  {}
-          specify('group 1-1 example 9')  {}
-          specify('group 1-1 example 10') {}
-        end
-
-        describe('group 1-2')  { specify('example') {} }
-        describe('group 1-3')  { specify('example') {} }
-        describe('group 1-4')  { specify('example') {} }
-        describe('group 1-5')  { specify('example') {} }
-        describe('group 1-6')  { specify('example') {} }
-        describe('group 1-7')  { specify('example') {} }
-        describe('group 1-8')  { specify('example') {} }
-        describe('group 1-9')  { specify('example') {} }
-        describe('group 1-10') { specify('example') {} }
-      end
-
-      RSpec.describe('group 2')  { specify('example') {} }
-      RSpec.describe('group 3')  { specify('example') {} }
-      RSpec.describe('group 4')  { specify('example') {} }
-      RSpec.describe('group 5')  { specify('example') {} }
-      RSpec.describe('group 6')  { specify('example') {} }
-      RSpec.describe('group 7')  { specify('example') {} }
-      RSpec.describe('group 8')  { specify('example') {} }
-      RSpec.describe('group 9')  { specify('example') {} }
-      RSpec.describe('group 10') { specify('example') {} }
-    "
-  end
-
-  describe '--order rand' do
-    it 'runs the examples and groups in a different order each time' do
-      run_command 'spec/order_spec.rb --order rand -f doc'
-      original_seed = srand
-      RSpec.configuration.seed = srand # reset seed in same process
-      run_command 'spec/order_spec.rb --order rand -f doc'
-      srand original_seed
-
-      expect(stdout.string).to match(/Randomized with seed \d+/)
-
-      top_level_groups      {|first_run, second_run| expect(first_run).to_not eq(second_run)}
-      nested_groups         {|first_run, second_run| expect(first_run).to_not eq(second_run)}
-      examples('group 1')   {|first_run, second_run| expect(first_run).to_not eq(second_run)}
-      examples('group 1-1') {|first_run, second_run| expect(first_run).to_not eq(second_run)}
-    end
-  end
-
-  describe '--order rand:SEED' do
-    it 'runs the examples and groups in the same order each time' do
-      2.times { run_command 'spec/order_spec.rb --order rand:123 -f doc' }
-
-      expect(stdout.string).to match(/Randomized with seed 123/)
-
-      top_level_groups      {|first_run, second_run| expect(first_run).to eq(second_run)}
-      nested_groups         {|first_run, second_run| expect(first_run).to eq(second_run)}
-      examples('group 1')   {|first_run, second_run| expect(first_run).to eq(second_run)}
-      examples('group 1-1') {|first_run, second_run| expect(first_run).to eq(second_run)}
-    end
-  end
-
-  describe '--seed SEED' do
-    it "forces '--order rand' and runs the examples and groups in the same order each time" do
-      2.times { run_command 'spec/order_spec.rb --seed 123 -f doc' }
-
-      expect(stdout.string).to match(/Randomized with seed 123/)
-
-      top_level_groups      {|first_run, second_run| expect(first_run).to eq(second_run)}
-      nested_groups         {|first_run, second_run| expect(first_run).to eq(second_run)}
-      examples('group 1')   {|first_run, second_run| expect(first_run).to eq(second_run)}
-      examples('group 1-1') {|first_run, second_run| expect(first_run).to eq(second_run)}
-    end
-
-    it "runs examples in the same order, regardless of the order in which files are given" do
-      run_command 'spec/simple_spec.rb spec/simple_spec2.rb --seed 1337 -f doc'
-      run_command 'spec/simple_spec2.rb spec/simple_spec.rb --seed 1337 -f doc'
-
-      top_level_groups      {|first_run, second_run| expect(first_run).to eq(second_run)}
-      nested_groups         {|first_run, second_run| expect(first_run).to eq(second_run)}
-    end
-  end
-
-  describe '--order rand --order recently-modified' do
-    it 'overrides random ordering with recently-modified option' do
-      2.times { run_command 'spec/order_spec.rb --order rand --order recently-modified -f doc' }
-
-      expect(stdout.string).not_to match(/Randomized with seed/)
-
-      top_level_groups { |first_run, second_run| expect(first_run).to eq(second_run) }
-      nested_groups { |first_run, second_run| expect(first_run).to eq(second_run) }
-    end
-  end
-
-  describe '--order defined on CLI with --order rand in .rspec' do
-    after { remove '.rspec' }
-
-    it "overrides --order rand with --order defined" do
-      write_file '.rspec', '--order rand'
-
-      run_command 'spec/order_spec.rb --order defined -f doc'
-
-      expect(stdout.string).not_to match(/Randomized/)
-
-      expect(stdout.string).to match(
-        /group 1.*group 1 example 1.*group 1 example 2.*group 1-1.*group 1-2.*group 2.*/m
-      )
-    end
-  end
-
-  context 'when a custom order is configured' do
-    after { remove 'spec/custom_order_spec.rb' }
-
-    before do
-      write_file 'spec/custom_order_spec.rb', "
-        RSpec.configure do |config|
-          config.register_ordering :global do |list|
-            list.sort_by { |item| item.description }
-          end
-        end
-
-        RSpec.describe 'group B' do
-          specify('group B example D')  {}
-          specify('group B example B')  {}
-          specify('group B example A')  {}
-          specify('group B example C')  {}
-        end
-
-        RSpec.describe 'group A' do
-          specify('group A example 1')  {}
-        end
-      "
-    end
-
-    it 'orders the groups and examples by the provided strategy' do
-      run_command 'spec/custom_order_spec.rb -f doc'
-
-      top_level_groups    { |groups| expect(groups.flatten).to eq(['group A', 'group B']) }
-      examples('group B') do |examples|
-        letters = examples.flatten.map { |e| e[/(.)\z/, 1] }
-        expect(letters).to eq(['A', 'B', 'C', 'D'])
-      end
-    end
-  end
-
-  def examples(group)
-    yield split_in_half(stdout.string.scan(/^\s+#{group} example.*$/))
-  end
-
-  def top_level_groups
-    yield example_groups_at_level(0)
-  end
-
-  def nested_groups
-    yield example_groups_at_level(2)
-  end
-
-  def example_groups_at_level(level)
-    split_in_half(stdout.string.scan(/^\s{#{level*2}}group.*$/))
-  end
-
-  def split_in_half(array)
-    length, midpoint = array.length, array.length / 2
-    return array.slice(0, midpoint), array.slice(midpoint, length)
-  end
-end
diff --git a/rspec-core/spec/integration/output_stream_spec.rb b/rspec-core/spec/integration/output_stream_spec.rb
deleted file mode 100644
index c369fac94..000000000
--- a/rspec-core/spec/integration/output_stream_spec.rb
+++ /dev/null
@@ -1,71 +0,0 @@
-require 'support/aruba_support'
-
-RSpec.describe 'Output stream' do
-  include_context 'aruba support'
-
-  context 'when a formatter set in a configure block' do
-    it 'writes to the right output stream' do
-      write_file_formatted 'spec/example_spec.rb', <<-SPEC
-        RSpec.configure do |c|
-          c.formatter = :documentation
-          c.output_stream = File.open('saved_output', 'w')
-        end
-
-        RSpec.describe 'something' do
-          it 'succeeds' do
-            true
-          end
-        end
-      SPEC
-
-      run_command ''
-      expect(last_cmd_stdout).to be_empty
-      cd '.' do
-        expect(File.read('saved_output')).to include('1 example, 0 failures')
-      end
-    end
-
-    it 'writes to the right output stream even when its a filename' do
-      write_file_formatted 'spec/example_spec.rb', <<-SPEC
-        RSpec.configure do |c|
-          c.formatter = :documentation
-          c.output_stream = 'saved_output'
-        end
-
-        RSpec.describe 'something' do
-          it 'succeeds' do
-            true
-          end
-        end
-      SPEC
-
-      run_command ''
-      expect(last_cmd_stdout).to be_empty
-      cd '.' do
-        expect(File.read('saved_output')).to include('1 example, 0 failures')
-      end
-    end
-
-    it 'writes to the right output stream even when its a filename' do
-      write_file_formatted 'spec/example_spec.rb', <<-SPEC
-        require 'pathname'
-        RSpec.configure do |c|
-          c.formatter = :documentation
-          c.output_stream = Pathname.new('saved_output')
-        end
-
-        RSpec.describe 'something' do
-          it 'succeeds' do
-            true
-          end
-        end
-      SPEC
-
-      run_command ''
-      expect(last_cmd_stdout).to be_empty
-      cd '.' do
-        expect(File.read('saved_output')).to include('1 example, 0 failures')
-      end
-    end
-  end
-end
diff --git a/rspec-core/spec/integration/persistence_failures_spec.rb b/rspec-core/spec/integration/persistence_failures_spec.rb
deleted file mode 100644
index e2c5f0a1f..000000000
--- a/rspec-core/spec/integration/persistence_failures_spec.rb
+++ /dev/null
@@ -1,69 +0,0 @@
-require 'support/aruba_support'
-
-RSpec.describe 'Persistence failures' do
-  include_context "aruba support"
-
-  context "when `config.example_status_persistence_file_path` is configured" do
-    context "to an invalid file path (e.g. spec/spec_helper.rb/examples.txt)" do
-      before do
-        write_file_formatted "spec/1_spec.rb", "
-          RSpec.configure do |c|
-            c.example_status_persistence_file_path = 'spec/1_spec.rb/examples.txt'
-          end
-          RSpec.describe { example { } }
-        "
-      end
-
-      it 'emits a helpful warning to the user, indicating we cannot write to it, and still runs the spec suite' do
-        run_command "spec/1_spec.rb"
-
-        expect(last_cmd_stderr).to include(
-          "WARNING: Could not write",
-          "spec/1_spec.rb/examples.txt",
-          "config.example_status_persistence_file_path",
-          "Errno:"
-        )
-        expect(last_cmd_stdout).to include("1 example")
-      end
-    end
-
-    context "to a file path for which we lack permissions" do
-      before do
-        write_file_formatted "spec/1_spec.rb", "
-          RSpec.configure do |c|
-            c.example_status_persistence_file_path = 'spec/examples.txt'
-          end
-          RSpec.describe { example { } }
-        "
-
-        write_file_formatted "spec/examples.txt", ""
-        cd '.' do
-          FileUtils.chmod 0000, "spec/examples.txt"
-        end
-      end
-
-
-      it 'emits a helpful warning to the user, indicating we cannot read from it, and still runs the spec suite' do
-        skip "Legacy builds run as root and this will never pass" if ENV['LEGACY_CI']
-        run_command "spec/1_spec.rb"
-
-        expected_snippets = [
-          "WARNING: Could not read",
-          "spec/examples.txt",
-          "config.example_status_persistence_file_path",
-          "Errno:"
-        ]
-
-        if RSpec::Support::OS.windows?
-          # Not sure why, but on windows it doesn't trigger the read error, it
-          # triggers a write error instead. The important thing is that whatever
-          # system error occurs is reported accurately.
-          expected_snippets[0] = "WARNING: Could not write"
-        end
-
-        expect(last_cmd_stderr).to include(*expected_snippets)
-        expect(last_cmd_stdout).to include("1 example")
-      end
-    end
-  end
-end
diff --git a/rspec-core/spec/integration/spec_file_load_errors_spec.rb b/rspec-core/spec/integration/spec_file_load_errors_spec.rb
deleted file mode 100644
index cbd88735d..000000000
--- a/rspec-core/spec/integration/spec_file_load_errors_spec.rb
+++ /dev/null
@@ -1,273 +0,0 @@
-require 'support/aruba_support'
-require 'support/formatter_support'
-
-RSpec.describe 'Spec file load errors' do
-  include_context "aruba support"
-  include FormatterSupport
-
-  let(:failure_exit_code) { rand(97) + 2 } # 2..99
-  let(:error_exit_code) { failure_exit_code + 1 } # 3..100
-
-  if RSpec::Support::Ruby.jruby_9000?
-    let(:spec_line_suffix) { ":in #{quoted('<main>')}" }
-  elsif RSpec::Support::Ruby.jruby?
-    let(:spec_line_suffix) { ":in #{quoted('(root)')}" }
-  elsif RUBY_VERSION == "1.8.7"
-    let(:spec_line_suffix) { "" }
-  else
-    let(:spec_line_suffix) { ":in #{quoted('<top (required)>')}" }
-  end
-
-  before do
-    RSpec.configure do |c|
-      c.filter_gems_from_backtrace "gems/aruba"
-      c.filter_gems_from_backtrace "gems/bundler"
-      c.backtrace_exclusion_patterns << %r{/rspec-core/spec/} << %r{rspec_with_simplecov}
-      c.failure_exit_code = failure_exit_code
-      c.error_exit_code = error_exit_code
-    end
-  end
-
-  it 'nicely handles load errors from --require files' do
-    run_command "--require ./helper_with_load_error"
-    expect(last_cmd_exit_status).to eq(error_exit_code)
-    output = normalize_durations(last_cmd_stdout)
-    expect(output).to include("An error occurred while loading ./helper_with_load_error.")
-    expect(output).to include("LoadError:")
-  end
-
-  it 'nicely handles syntax errors from --require files' do
-    write_file_formatted "helper_with_syntax_error.rb", "3 = hello"
-
-    run_command "--require ./helper_with_syntax_error"
-    expect(last_cmd_exit_status).to eq(error_exit_code)
-    output = normalize_durations(last_cmd_stdout)
-    expect(output).to include("While loading ./helper_with_syntax_error a `raise SyntaxError` occurred, RSpec will now quit.")
-  end
-
-  it 'nicely handles load-time errors from --require files' do
-    write_file_formatted "helper_with_error.rb", "raise 'boom'"
-
-    run_command "--require ./helper_with_error"
-    expect(last_cmd_exit_status).to eq(error_exit_code)
-    output = normalize_durations(last_cmd_stdout)
-    expect(output).to eq unindent(<<-EOS)
-
-      An error occurred while loading ./helper_with_error.
-      Failure/Error: raise 'boom'
-
-      RuntimeError:
-        boom
-      # ./helper_with_error.rb:1#{spec_line_suffix}
-      No examples found.
-
-
-      Finished in n.nnnn seconds (files took n.nnnn seconds to load)
-      0 examples, 0 failures, 1 error occurred outside of examples
-
-    EOS
-  end
-
-  it 'prints a single error when it happens on --require files' do
-    write_file_formatted "helper_with_error.rb", "raise 'boom'"
-
-    write_file_formatted "1_spec.rb", "
-      RSpec.describe 'A broken spec file that will raise when loaded' do
-        raise 'kaboom'
-      end
-    "
-
-    run_command "--require ./helper_with_error 1_spec.rb"
-    expect(last_cmd_exit_status).to eq(error_exit_code)
-    output = normalize_durations(last_cmd_stdout)
-    expect(output).to eq unindent(<<-EOS)
-
-      An error occurred while loading ./helper_with_error.
-      Failure/Error: raise 'boom'
-
-      RuntimeError:
-        boom
-      # ./helper_with_error.rb:1#{spec_line_suffix}
-      No examples found.
-
-
-      Finished in n.nnnn seconds (files took n.nnnn seconds to load)
-      0 examples, 0 failures, 1 error occurred outside of examples
-
-    EOS
-  end
-
-  it 'prints a warning when a helper file exits early' do
-    write_file_formatted "helper_with_exit.rb", "exit 999"
-
-    expect {
-      run_command "--require ./helper_with_exit.rb"
-    }.to raise_error(SystemExit)
-    output = normalize_durations(last_cmd_stdout)
-    # Remove extra line which is only shown on CRuby
-    output = output.sub("# ./helper_with_exit.rb:1:in #{quoted('exit')}\n", "")
-
-    if defined?(JRUBY_VERSION) && !JRUBY_VERSION.empty?
-      expect(output).to eq unindent(<<-EOS)
-
-        While loading ./helper_with_exit.rb an `exit` / `raise SystemExit` occurred, RSpec will now quit.
-        Failure/Error: Unable to find org/jruby/RubyKernel.java to read failed line
-
-        SystemExit:
-          exit
-        # ./helper_with_exit.rb:1#{spec_line_suffix}
-      EOS
-    else
-      string = <<-EOS
-
-        While loading ./helper_with_exit.rb an `exit` / `raise SystemExit` occurred, RSpec will now quit.
-        Failure/Error: exit 999
-
-        SystemExit:
-          exit
-      EOS
-      string += "# ./helper_with_exit.rb:1:in 'Kernel#exit'\n" if RUBY_VERSION.to_f > 3.3
-      string += "# ./helper_with_exit.rb:1#{spec_line_suffix}\n"
-      expect(output).to eq unindent(string)
-    end
-  end
-
-  it 'nicely handles load-time errors in user spec files', :disable_error_highlight => true do
-    write_file_formatted "1_spec.rb", "
-      boom
-
-      RSpec.describe 'Calling boom' do
-        it 'will not run this example' do
-          expect(1).to eq 1
-        end
-      end
-    "
-
-    write_file_formatted "2_spec.rb", "
-      RSpec.describe 'No Error' do
-        it 'will not run this example, either' do
-          expect(1).to eq 1
-        end
-      end
-    "
-
-    write_file_formatted "3_spec.rb", "
-      boom
-
-      RSpec.describe 'Calling boom again' do
-        it 'will not run this example, either' do
-          expect(1).to eq 1
-        end
-      end
-    "
-
-    run_command "1_spec.rb 2_spec.rb 3_spec.rb"
-    expect(last_cmd_exit_status).to eq(error_exit_code)
-    output = normalize_durations(last_cmd_stdout)
-
-    object_suffix =
-      if RUBY_VERSION.to_f > 3.2
-        ""
-      else
-        ":Object"
-      end
-
-    expect(output).to eq unindent(<<-EOS)
-
-      An error occurred while loading ./1_spec.rb.
-      Failure/Error: boom
-
-      NameError:
-        undefined local variable or method #{quoted('boom')} for main#{object_suffix}
-      # ./1_spec.rb:1#{spec_line_suffix}
-
-      An error occurred while loading ./3_spec.rb.
-      Failure/Error: boom
-
-      NameError:
-        undefined local variable or method #{quoted('boom')} for main#{object_suffix}
-      # ./3_spec.rb:1#{spec_line_suffix}
-
-
-      Finished in n.nnnn seconds (files took n.nnnn seconds to load)
-      0 examples, 0 failures, 2 errors occurred outside of examples
-
-    EOS
-  end
-
-  describe 'handling syntax errors' do
-    let(:formatted_output) { normalize_durations(last_cmd_stdout).gsub(Dir.pwd, '.').gsub(/\e\[[0-9;]+m/, '') }
-
-    before(:example) do
-      write_file_formatted "broken_file.rb", "
-      class WorkInProgress
-        def initialize(arg)
-        def foo
-        end
-      end
-      "
-    end
-
-    if RSpec::Support::RubyFeatures.supports_syntax_suggest?
-      it 'uses syntax_suggest formatting when available' do
-        in_sub_process do
-          require "syntax_suggest"
-
-          run_command "--require ./broken_file"
-          expect(last_cmd_exit_status).to eq(error_exit_code)
-
-          expect(formatted_output).to include unindent(<<-EOS)
-            While loading ./broken_file a `raise SyntaxError` occurred, RSpec will now quit.
-          EOS
-
-          # A fix was backported to 3.2.3
-          if RUBY_VERSION > '3.2.2'
-            expect(formatted_output.gsub("\n\n", "\n")).to include unindent(<<-EOS)
-            SyntaxError:
-              --> ./tmp/aruba/broken_file.rb
-              Unmatched keyword, missing `end' ?
-                1  class WorkInProgress
-              > 2    def initialize(arg)
-                3    def foo
-                4    end
-                5  end
-            EOS
-          else
-            expect(formatted_output).to include unindent(<<-EOS)
-            SyntaxError:
-              --> ./tmp/aruba/broken_file.rb
-              Unmatched keyword, missing `end' ?
-                1  class WorkInProgress
-              > 2    def initialize(arg)
-                4    end
-                5  end
-            EOS
-          end
-          expect(formatted_output).to include %r{./tmp/aruba/broken_file.rb:\d: syntax error}
-
-          expect(formatted_output).to include unindent(<<-EOS)
-            Finished in n.nnnn seconds (files took n.nnnn seconds to load)
-            0 examples, 0 failures, 1 error occurred outside of examples
-          EOS
-        end
-      end
-    else
-      it 'prints a basic error when no syntax_suggest is available/loaded', :skip => RUBY_VERSION.to_f < 1.9 || RSpec::Support::Ruby.jruby? do
-        run_command "--require ./broken_file"
-        expect(last_cmd_exit_status).to eq(error_exit_code)
-
-        expect(formatted_output).to include unindent(<<-EOS)
-          While loading ./broken_file a `raise SyntaxError` occurred, RSpec will now quit.
-        EOS
-
-        # This is subset of the formatted_output, it continues slightly but differs on different Rubies
-        expect(formatted_output).to include "SyntaxError:\n  ./tmp/aruba/broken_file.rb:5: syntax error"
-
-        expect(formatted_output).to include unindent(<<-EOS)
-          Finished in n.nnnn seconds (files took n.nnnn seconds to load)
-          0 examples, 0 failures, 1 error occurred outside of examples
-        EOS
-      end
-    end
-  end
-end
diff --git a/rspec-core/spec/integration/suite_hooks_errors_spec.rb b/rspec-core/spec/integration/suite_hooks_errors_spec.rb
deleted file mode 100644
index 7cc2dc6a6..000000000
--- a/rspec-core/spec/integration/suite_hooks_errors_spec.rb
+++ /dev/null
@@ -1,147 +0,0 @@
-require 'support/aruba_support'
-require 'support/formatter_support'
-
-RSpec.describe 'Suite hook errors' do
-  include_context "aruba support"
-  include FormatterSupport
-
-  let(:failure_exit_code) { rand(97) + 2 } # 2..99
-  let(:error_exit_code) { failure_exit_code + 2 } # 4..101
-
-  if RSpec::Support::Ruby.jruby_9000? && RSpec::Support::Ruby.jruby_version > '9.2.0.0'
-    let(:spec_line_suffix) { ":in #{quoted('block in <main>')}" }
-  elsif RSpec::Support::Ruby.jruby_9000?
-    let(:spec_line_suffix) { ":in #{quoted('block in (root)')}" }
-  elsif RSpec::Support::Ruby.jruby?
-    let(:spec_line_suffix) { ":in #{quoted('(root)')}" }
-  elsif RUBY_VERSION == "1.8.7"
-    let(:spec_line_suffix) { "" }
-  else
-    let(:spec_line_suffix) { ":in #{quoted('block (2 levels) in <top (required)>')}" }
-  end
-
-  before do
-    RSpec.configure do |c|
-      c.filter_gems_from_backtrace "gems/aruba"
-      c.filter_gems_from_backtrace "gems/bundler"
-      c.backtrace_exclusion_patterns << %r{/rspec-core/spec/} << %r{rspec_with_simplecov}
-      c.failure_exit_code = failure_exit_code
-      c.error_exit_code = error_exit_code
-    end
-  end
-
-  def run_spec_expecting_non_zero(before_or_after)
-    write_file "the_spec.rb", "
-      RSpec.configure do |c|
-        c.#{before_or_after}(:suite) do
-          raise 'boom'
-        end
-      end
-
-      RSpec.describe do
-        it { }
-      end
-    "
-
-    run_command "the_spec.rb"
-    expect(last_cmd_exit_status).to eq(error_exit_code)
-    normalize_durations(last_cmd_stdout)
-  end
-
-  it 'nicely formats errors in `before(:suite)` hooks and exits with non-zero' do
-    output = run_spec_expecting_non_zero(:before)
-    expect(output).to eq unindent(<<-EOS)
-
-      An error occurred in a `before(:suite)` hook.
-      Failure/Error: raise 'boom'
-
-      RuntimeError:
-        boom
-      # ./the_spec.rb:4#{spec_line_suffix}
-
-
-      Finished in n.nnnn seconds (files took n.nnnn seconds to load)
-      0 examples, 0 failures, 1 error occurred outside of examples
-
-    EOS
-  end
-
-  it 'nicely formats errors in `after(:suite)` hooks and exits with non-zero' do
-    output = run_spec_expecting_non_zero(:after)
-    expect(output).to eq unindent(<<-EOS)
-      .
-      An error occurred in an `after(:suite)` hook.
-      Failure/Error: raise 'boom'
-
-      RuntimeError:
-        boom
-      # ./the_spec.rb:4#{spec_line_suffix}
-
-
-      Finished in n.nnnn seconds (files took n.nnnn seconds to load)
-      1 example, 0 failures, 1 error occurred outside of examples
-
-    EOS
-  end
-
-  it 'nicely formats errors from multiple :suite hooks of both types and exits with non-zero' do
-    write_file "the_spec.rb", "
-      RSpec.configure do |c|
-        c.before(:suite) { raise 'before 1' }
-        c.before(:suite) { raise 'before 2' }
-        c.after(:suite) { raise 'after 1' }
-        c.after(:suite) { raise 'after 2' }
-      end
-
-      RSpec.describe do
-        it { }
-      end
-    "
-
-    cause =
-      if RSpec::Support::Ruby.jruby_9000? && RSpec::Support::Ruby.jruby_version > '9.2.0.0'
-        unindent(<<-EOS)
-          # ------------------
-          # --- Caused by: ---
-          # RuntimeError:
-          #   before 1
-          #   ./the_spec.rb:3:in #{quoted('block in <main>')}
-        EOS
-      else
-        ""
-      end
-
-    run_command "the_spec.rb"
-    expect(last_cmd_exit_status).to eq(error_exit_code)
-    output = normalize_durations(last_cmd_stdout)
-
-    expect(output).to eq unindent(<<-EOS)
-
-      An error occurred in a `before(:suite)` hook.
-      Failure/Error: c.before(:suite) { raise 'before 1' }
-
-      RuntimeError:
-        before 1
-      # ./the_spec.rb:3#{spec_line_suffix}
-
-      An error occurred in an `after(:suite)` hook.
-      Failure/Error: c.after(:suite) { raise 'after 2' }
-
-      RuntimeError:
-        after 2
-      # ./the_spec.rb:6#{spec_line_suffix}
-      #{ cause }
-      An error occurred in an `after(:suite)` hook.
-      Failure/Error: c.after(:suite) { raise 'after 1' }
-
-      RuntimeError:
-        after 1
-      # ./the_spec.rb:5#{spec_line_suffix}
-      #{ cause }
-
-      Finished in n.nnnn seconds (files took n.nnnn seconds to load)
-      0 examples, 0 failures, 3 errors occurred outside of examples
-
-    EOS
-  end
-end
diff --git a/rspec-core/spec/rspec/core_spec.rb b/rspec-core/spec/rspec/core_spec.rb
deleted file mode 100644
index 9722d8ce8..000000000
--- a/rspec-core/spec/rspec/core_spec.rb
+++ /dev/null
@@ -1,344 +0,0 @@
-require 'rspec/support/spec/library_wide_checks'
-
-RSpec.describe RSpec do
-  fake_libs = File.expand_path('../../support/fake_libs', __FILE__)
-  allowed_loaded_features = [
-    /optparse\.rb/,   # Used by OptionParser.
-    /rbconfig\.rb/,   # loaded by rspec-support for OS detection.
-    /shellwords\.rb/, # used by ConfigurationOptions and RakeTask.
-    /stringio/,       # Used by BaseFormatter.
-    %r{/fake_libs/},  # ignore these, obviously
-  ]
-
-  # JRuby appears to not respect `--disable=gem` so rubygems also gets loaded.
-  allowed_loaded_features << /rubygems/ if RSpec::Support::Ruby.jruby?
-
-  # Truffleruby cext files
-  allowed_loaded_features << /\/truffle\/cext/ if RSpec::Support::Ruby.truffleruby?
-
-  disable_autorun_code =
-    if RSpec::Support::OS.windows?
-      # On Windows, the "redefine autorun" approach results in a different
-      # exit status for a reason I don't understand, so we just disable
-      # autorun outright.
-      'RSpec::Core::Runner.disable_autorun!'
-    else
-      # On JRuby, the `disable_autorun!` approach leads to a stderr warning
-      # related to a deprecation emited when `rspec/core/autorun` gets loaded,
-      # because of `caller_filter` issues, so we redefine the autorun method
-      # instead. That works fine on all Rubies when we're not on Windows as
-      # well.
-      'RSpec::Core::Runner.instance_exec { undef :autorun; def autorun; end }'
-    end
-
-  it_behaves_like 'library wide checks', 'rspec-core',
-    :preamble_for_lib => [
-      # rspec-core loads a number of external libraries. We don't want them loaded
-      # as part of loading all of rspec-core for these specs, for a few reasons:
-      #
-      #   * Some external libraries issue warnings, which we can't do anything about.
-      #     Since we are trying to prevent _any_ warnings from loading RSpec, it's
-      #     easiest to avoid loading those libraries entirely.
-      #   * Some external libraries load many stdlibs. Here we allow a known set of
-      #     directly loaded stdlibs, and we're not directly concerned with transitive
-      #     dependencies.
-      #   * We're really only concerned with these issues w.r.t. rspec-mocks and
-      #     rspec-expectations from within their spec suites. Here we care only about
-      #     rspec-core, so avoiding loading them helps keep the spec suites independent.
-      #   * These are some of the slowest specs we have, and cutting out the loading
-      #     of external libraries cuts down on how long these specs take.
-      #
-      # To facilitate the avoidance of loading certain libraries, we have a bunch
-      # of files in `support/fake_libs` that substitute for the real things when
-      # we put that directory on the load path. Here's the list:
-      #
-      #   * coderay -- loaded by the HTML formatter if available for syntax highlighting.
-      #   * drb -- loaded when `--drb` is used. Loads other stdlibs (socket, thread, fcntl).
-      #   * erb -- loaded by `ConfigurationOptions` so `.rspec` can use ERB. Loads other stdlibs (strscan, cgi/util).
-      #   * flexmock -- loaded by our Flexmock mocking adapter.
-      #   * json -- loaded by the JSON formatter, loads other stdlibs (ostruct, enc/utf_16le.bundle, etc).
-      #   * minitest -- loaded by our Minitest assertions adapter.
-      #   * mocha -- loaded by our Mocha mocking adapter.
-      #   * rake -- loaded by our Rake task. Loads other stdlibs (fileutils, ostruct, thread, monitor, etc).
-      #   * rr -- loaded by our RR mocking adapter.
-      #   * rspec-mocks -- loaded by our RSpec mocking adapter.
-      #   * rspec-expectations -- loaded by the generated `spec_helper` (defined in project_init).
-      #   * test-unit -- loaded by our T::U assertions adapter.
-      #
-      "$LOAD_PATH.unshift '#{fake_libs}'",
-      # Many files assume this has already been loaded and will have errors if it has not.
-      'require "rspec/core"',
-      # Prevent rspec/autorun from trying to run RSpec.
-      disable_autorun_code
-    ], :skip_spec_files => %r{/fake_libs/}, :allowed_loaded_feature_regexps => allowed_loaded_features do
-    if RUBY_VERSION == '1.8.7'
-      before(:example, :description => /(issues no warnings when the spec files are loaded|stdlibs)/) do
-        pending "Not working on #{RUBY_DESCRIPTION}"
-      end
-    elsif RUBY_VERSION == '2.0.0' && RSpec::Support::Ruby.jruby?
-      before(:example) do
-        skip "Not reliably working on #{RUBY_DESCRIPTION}"
-      end
-    elsif RUBY_VERSION.start_with?('2.4')
-      before(:example, :description => /spec files/) do
-        skip "Ruby 2.4.0 is producing a warning due to aruba"
-      end
-    elsif RSpec::Support::Ruby.jruby? && JRUBY_VERSION =~ /9\.1\.17\.0/
-      before(:example, :description => /spec files/) do
-        skip "JRuby 9.1.17.0 generates unrelated warnings"
-      end
-    end
-  end
-
-  describe ".configuration" do
-    it "returns the same object every time" do
-      expect(RSpec.configuration).to equal(RSpec.configuration)
-    end
-  end
-
-  describe ".configuration=" do
-    it "sets the configuration object" do
-      configuration = RSpec::Core::Configuration.new
-
-      RSpec.configuration = configuration
-
-      expect(RSpec.configuration).to equal(configuration)
-    end
-  end
-
-  describe ".configure" do
-    it "yields the current configuration" do
-      RSpec.configure do |config|
-        expect(config).to equal(RSpec::configuration)
-      end
-    end
-  end
-
-  describe ".world" do
-    it "returns the same object every time" do
-      expect(RSpec.world).to equal(RSpec.world)
-    end
-  end
-
-  describe ".world=" do
-    it "sets the world object" do
-      world = RSpec::Core::World.new
-
-      RSpec.world = world
-
-      expect(RSpec.world).to equal(world)
-    end
-  end
-
-  describe ".current_example" do
-    it "sets the example being executed" do
-      group = RSpec.describe("an example group")
-      example = group.example("an example")
-
-      RSpec.current_example = example
-      expect(RSpec.current_example).to be(example)
-    end
-  end
-
-  describe ".current_scope" do
-    before :context do
-      expect(RSpec.current_scope).to eq(:before_context_hook)
-    end
-
-    before do
-      expect(RSpec.current_scope).to eq(:before_example_hook)
-    end
-
-    it "returns :example inside an example" do
-      expect(RSpec.current_scope).to eq(:example)
-    end
-  end
-
-  describe ".reset" do
-    it "resets the configuration and world objects" do
-      config_before_reset = RSpec.configuration
-      world_before_reset  = RSpec.world
-
-      RSpec.reset
-
-      expect(RSpec.configuration).not_to equal(config_before_reset)
-      expect(RSpec.world).not_to equal(world_before_reset)
-    end
-
-    it 'removes the previously assigned example group constants' do
-        RSpec.describe "group"
-
-        expect {
-          RSpec.world.reset
-        }.to change(RSpec::ExampleGroups, :constants).to([])
-    end
-  end
-
-  describe ".clear_examples" do
-    let(:listener) { double("listener") }
-
-    def reporter
-      RSpec.configuration.reporter
-    end
-
-    before do
-      RSpec.configuration.output_stream = StringIO.new
-      RSpec.configuration.error_stream = StringIO.new
-    end
-
-    it "clears example groups" do
-      RSpec.world.example_groups << :example_group
-
-      RSpec.clear_examples
-
-      expect(RSpec.world.example_groups).to be_empty
-    end
-
-    it "resets start_time" do
-      start_time_before_clear = RSpec.configuration.start_time
-
-      RSpec.clear_examples
-
-      expect(RSpec.configuration.start_time).not_to eq(start_time_before_clear)
-    end
-
-    it "clears examples, failed_examples and pending_examples" do
-      reporter.start(3)
-      pending_ex = failing_ex = nil
-
-      RSpec.describe do
-        pending_ex = pending { fail }
-        failing_ex = example { fail }
-      end.run
-
-      reporter.example_started(failing_ex)
-      reporter.example_failed(failing_ex)
-
-      reporter.example_started(pending_ex)
-      reporter.example_pending(pending_ex)
-      reporter.finish
-
-      RSpec.clear_examples
-
-      reporter.register_listener(listener, :dump_summary)
-
-      expect(listener).to receive(:dump_summary) do |notification|
-        expect(notification.examples).to be_empty
-        expect(notification.failed_examples).to be_empty
-        expect(notification.pending_examples).to be_empty
-      end
-
-      reporter.start(0)
-      reporter.finish
-    end
-
-    it "restores inclusion rules set by configuration" do
-      file_path = File.expand_path("foo_spec.rb")
-      RSpec.configure do |config|
-        config.filter_run_including(:locations => { file_path => [12] })
-      end
-      allow(RSpec.configuration).to receive(:load).with(file_path)
-      allow(reporter).to receive(:report)
-      RSpec::Core::Runner.run(["foo_spec.rb:14"])
-
-      expect(
-        RSpec.configuration.filter_manager.inclusions[:locations]
-      ).to eq(file_path => [12, 14])
-
-      RSpec.clear_examples
-
-      expect(
-        RSpec.configuration.filter_manager.inclusions[:locations]
-      ).to eq(file_path => [12])
-    end
-
-    it "restores exclusion rules set by configuration" do
-      RSpec.configure { |config| config.filter_run_excluding(:slow => true) }
-      allow(RSpec.configuration).to receive(:load)
-      allow(reporter).to receive(:report)
-      RSpec::Core::Runner.run(["--tag", "~fast"])
-
-      expect(
-        RSpec.configuration.filter_manager.exclusions.rules
-      ).to eq(:slow => true, :fast => true)
-
-      RSpec.clear_examples
-
-      expect(
-        RSpec.configuration.filter_manager.exclusions.rules
-      ).to eq(:slow => true)
-    end
-
-    it 'clears the deprecation buffer' do
-      RSpec.configuration.deprecation_stream = StringIO.new
-
-      RSpec.describe do
-        example { RSpec.deprecate("first deprecation") }
-      end.run
-
-      reporter.start(1)
-      reporter.finish
-
-      RSpec.clear_examples
-
-      RSpec.configuration.deprecation_stream = StringIO.new(deprecations = "".dup)
-
-      RSpec.describe do
-        example { RSpec.deprecate("second deprecation") }
-      end.run
-
-      reporter.start(1)
-      reporter.finish
-
-      expect(deprecations).to     include("second deprecation")
-      expect(deprecations).to_not include("first deprecation")
-    end
-
-    it 'does not clear shared examples' do
-      RSpec.shared_examples_for("shared") { }
-
-      RSpec.clear_examples
-
-      registry = RSpec.world.shared_example_group_registry
-      expect(registry.find([:main], "shared")).to_not be_nil
-    end
-  end
-
-  describe "::Core.path_to_executable" do
-    it 'returns the absolute location of the exe/rspec file' do
-      expect(File.exist? RSpec::Core.path_to_executable).to be(true)
-      expect(File.read(RSpec::Core.path_to_executable)).to include("RSpec::Core::Runner.invoke")
-      expect(File.executable? RSpec::Core.path_to_executable).to be(true) unless RSpec::Support::OS.windows?
-    end
-  end
-
-  include RSpec::Support::ShellOut
-
-  # This is hard to test :(. Best way I could come up with was starting
-  # fresh ruby process w/o this stuff already loaded.
-  it "loads mocks and expectations when the constants are referenced", :slow do
-    code = 'require "rspec"; puts RSpec::Mocks.name; puts RSpec::Expectations.name'
-    out, err, status = run_ruby_with_current_load_path(code)
-
-    expect(err).to eq("")
-    expect(out.split("\n")).to eq(%w[ RSpec::Mocks RSpec::Expectations ])
-    expect(status.exitstatus).to eq(0)
-
-    expect(RSpec.const_missing(:Expectations)).to be(RSpec::Expectations)
-  end
-
-  it 'correctly raises an error when an invalid const is referenced' do
-    expect {
-      RSpec::NotAConst
-    }.to raise_error(NameError, /RSpec::NotAConst/)
-  end
-
-  it "does not blow up if some gem defines `Kernel#it`", :slow do
-    code = 'Kernel.module_eval { def it(*); end }; require "rspec/core"'
-    out, err, status = run_ruby_with_current_load_path(code)
-
-    expect(err).to eq("")
-    expect(out).to eq("")
-    expect(status.exitstatus).to eq(0)
-  end
-end
diff --git a/rspec-core/spec/support/aruba_support.rb b/rspec-core/spec/support/aruba_support.rb
deleted file mode 100644
index b0718b1a1..000000000
--- a/rspec-core/spec/support/aruba_support.rb
+++ /dev/null
@@ -1,86 +0,0 @@
-require 'support/helper_methods'
-
-if RSpec::Support::Ruby.jruby? && RSpec::Support::Ruby.jruby_version == "9.1.17.0"
-  # A regression appeared in require_relative in JRuby 9.1.17.0 where require some
-  # how ends up private, this monkey patch uses `send`
-  module Kernel
-    module_function
-      def require_relative(relative_arg)
-        relative_arg = relative_arg.to_path if relative_arg.respond_to? :to_path
-        relative_arg = JRuby::Type.convert_to_str(relative_arg)
-
-        caller.first.rindex(/:\d+:in /)
-        file = $` # just the filename
-        raise LoadError, "cannot infer basepath" if /\A\((.*)\)/ =~ file # eval etc.
-
-        absolute_feature = File.expand_path(relative_arg, File.dirname(File.realpath(file)))
-
-        # This was the original:
-        # ::Kernel.require absolute_feature
-        ::Kernel.send(:require, absolute_feature)
-      end
-  end
-end
-
-module ArubaLoader
-  extend RSpec::Support::WithIsolatedStdErr
-  with_isolated_stderr do
-    require 'aruba/api'
-  end
-end
-
-RSpec.shared_context "aruba support" do
-  include Aruba::Api
-  include RSpecHelpers
-  let(:stderr) { StringIO.new }
-  let(:stdout) { StringIO.new }
-
-  before { setup_aruba }
-
-  attr_reader :last_cmd_stdout, :last_cmd_stderr, :last_cmd_exit_status
-
-  def run_command(cmd)
-    RSpec.configuration.color = true
-
-    temp_stdout = StringIO.new
-    temp_stderr = StringIO.new
-
-    # So that `RSpec.warning` will go to temp_stderr.
-    allow(::Kernel).to receive(:warn) { |msg| temp_stderr.puts(msg) }
-    cmd_parts = ["--no-profile"] + Shellwords.split(cmd)
-
-    handle_current_dir_change do
-      cd '.' do
-        with_isolated_stderr do
-          @last_cmd_exit_status = RSpec::Core::Runner.run(cmd_parts, temp_stderr, temp_stdout)
-        end
-      end
-    end
-  ensure
-    RSpec.reset
-    RSpec.configuration.color = true
-
-    # Ensure it gets cached with a proper value -- if we leave it set to nil,
-    # and the next spec operates in a different dir, it could get set to an
-    # invalid value.
-    RSpec::Core::Metadata.relative_path_regex
-
-    @last_cmd_stdout = temp_stdout.string
-    @last_cmd_stderr = temp_stderr.string
-    stdout.write(@last_cmd_stdout)
-    stderr.write(@last_cmd_stderr)
-  end
-
-  def write_file_formatted(file_name, contents)
-    # remove blank line at the start of the string and
-    # strip extra indentation.
-    formatted_contents = unindent(contents.sub(/\A\n/, ""))
-    write_file file_name, formatted_contents
-  end
-end
-
-RSpec.configure do |c|
-  c.define_derived_metadata(:file_path => %r{spec/integration}) do |meta|
-    meta[:slow] = true
-  end
-end
