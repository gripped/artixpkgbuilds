--- a/src/apulse-stream.c	2024-08-12 14:25:03.188763793 +0200
+++ b/src/apulse-stream.c	2024-08-12 14:31:56.053375168 +0200
@@ -58,6 +58,7 @@
     pa_stream_unref(s);
 }
 
+static int xruns=0;
 static void
 data_available_for_stream(pa_mainloop_api *a, pa_io_event *ioe, int fd,
                           pa_io_event_flags_t events, void *userdata)
@@ -171,11 +172,13 @@
     }
 
     if (events & PA_IO_EVENT_OUTPUT) {
+      int r;
+    
         if (paused) {
             // client stream is corked. Pass silence to ALSA
             size_t bytecnt = MIN(buf_size, frame_count * frame_size);
             memset(buf, 0, bytecnt);
-            snd_pcm_writei(s->ph, buf, bytecnt / frame_size);
+            r= snd_pcm_writei(s->ph, buf, bytecnt / frame_size);
         } else {
             size_t writable_size = pa_stream_writable_size(s);
 
@@ -193,9 +196,29 @@
                 // application is not ready yet, play silence
                 bytecnt = MIN(buf_size, frame_count * frame_size);
                 memset(buf, 0, bytecnt);
+		trace_warning("application not ready\n");
             }
-            snd_pcm_writei(s->ph, buf, bytecnt / frame_size);
+            r = snd_pcm_writei(s->ph, buf, bytecnt / frame_size);
         }
+
+        if (r < 0) {
+	 switch (r) {
+	   case -EAGAIN:  // non-blocking I/O, no need to do anything
+	     break;
+	   case -EBADFD:  // FD in wrong state
+	     trace_warning("ALSA badfd: rv=%d\n", r);
+	     snd_pcm_prepare(s->ph);
+	     break;
+	   case -EPIPE:  // XRUN
+	     xruns++;
+	     trace_warning("ALSA xrun: rv=%d, xruns=%d\n", r, xruns);
+	     snd_pcm_recover(s->ph, r, 1);
+	     break;
+	   default:
+	     trace_warning("ALSA error: rv=%d\n", r);
+	     snd_pcm_recover(s->ph, r, 1);
+	 }
+	}
     }
 
     if (events & PA_IO_EVENT_INPUT) {
