#!/bin/sh
#
# This script is based on KISS Linux's encryption script with MIT license.
#
# Copyright (c) 2021 Muhammad Herdiansyah
# Copyright (c) 2021 Artix Linux Developers
# Copyright (c) 2020 illiliti
# Copyright (c) 2019-2020 Dylan Araps
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# To keep consistency and to enable any interested parties to take anything
# from this source code without adding another license file, this file will also
# be licensed according to the terms above.

# disable globbing because we don't need it
set -f

unlock_devices() {
    exec 3<&0; while read -r name dev pass opts err; do

        # Skip comments.
        [ "${name##\#*}" ] || continue

        # Break on invalid crypttab.
        [ "$err" ] && {
            echo "A valid /etc/crypttab has only 4 columns. Aborting..."
            exit 99
        }

        # Turn 'UUID=*', 'LABEL=*', 'PARTUUID=*' into device name.
        case "${dev%%=*}" in UUID|LABEL|PARTUUID)
            for line in $(blkid); do case "${line%%=*}" in
                /dev/*)
                    _dev="${line%:}"
                ;;
                UUID|LABEL|PARTUUID)
                    _line="${line##*=}"
                    _line="${_line%\"}"
                    _line="${_line#\"}"

                    [ "$_line" = "${dev##*=}" ] && {
                        dev="$_dev"
                        break
                    }
                ;;
            esac; done
        esac

        # Parse options by turning the list into a pseudo array.
        # shellcheck disable=2086
        { IFS=,; set -- $opts; unset IFS; }

        # Create an argument list (no other way to do this in sh).
        # copts: common options
        # popts: plain options
        # lopts: LUKS options
        # topts: TrueCrypt options
        for opt; do case "$opt" in
            readonly|read-only) copts="$copts -r"              ;;
            tries=*)    copts="$copts -T ${opt##*=}"           ;;
            discard)    copts="$copts --allow-discards"        ;;
            verify)     copts="$copts -y"                      ;;
            noauto)     copts=; continue 2                     ;;
            sector-size=*) copts="$copts --${opt}"             ;;
            plain)      copts="$copts --type plain"; plain=y   ;;
            luks)       copts="$copts --type luks"; luks=y     ;;
            tcrypt)     copts="$copts --type tcrypt"; tcrypt=y ;
                echo "WARNING: TrueCrypt support in crypttab is considered experimental!" ;;
            bitlk)      copts="$copts --type bitlk";
                echo "WARNING: BitLocker support in crypttab is considered experimental!" ;;
            swap)       copts="$copts --type plain";
                        plain=y; swap=y                        ;;
            fvault2)    copts="$copts --type fvault2";
                echo "WARNING: FVault2 support in crypttab is considered experimental!" ;;
            cipher=*)   popts="$popts -c ${opt##*=}"           ;;
            size=*)     popts="$popts -s ${opt##*=}"           ;;
            hash=*)     popts="$popts -h ${opt##*=}"           ;;
            offset=*)   popts="$popts -o ${opt##*=}"           ;;
            skip=*)     popts="$popts -p ${opt##*=}"           ;;
            veracrypt|trycrypt-veracrypt)
                topts="$topts --veracrypt"  ;;
            tcrypthidden|tcrypt-hidden)
                topts="$topts --tcrypt-hidden" ;;
            keyfile-size=*) lopts="$lopts --${opt}"            ;;
            keyfile-offset=*) lopts="$lopts --${opt}"          ;;
            keyslot=*|key-slot=*) lopts="$lopts ${opt##*=}"    ;;
            header=*) lopts="$lopts --${opt}"                  ;;
        esac; done

        [ "$plain" = y ] && copts="$copts $popts"
        [ "$luks" = y ] && copts="$copts $lopts"
        [ "$tcrypt" = y ] && copts="$copts $topts"

        # If password is 'none', '-' or empty ask for it.
        # shellcheck disable=2086
        case "$pass" in
            none|-|"") cryptsetup $copts open "$dev" "$name" <&3 ;;
            *) cryptsetup $copts -d "$pass" open "$dev" "$name"  ;;
        esac

        [ "$swap" = y ] && mkswap "/dev/mapper/$name"
        copts=; popts=; lopts=; topts= plain=; luks=; tcrypt=;
    done < /etc/crypttab; exec 3>&-
}

lock_devices() {
    for file in /sys/block/dm-*; do
        IFS=- read -r dm_type _ _ _ < "$file/dm/uuid"

        # --deferred used to prevent hang on FDE systems
        [ "$dm_type" = CRYPT ] && cryptsetup close --deferred "$(cat "$file/dm/name")"
    done
}

# restore globbing
set +f

case "$1" in
    unlock)
        unlock_devices
        # LVM-on-LUKS scenario
        # shellcheck disable=2015
        dinitctl is-started --quiet lvm2 && vgchange --sysinit -a y >/dev/null || :
    ;;
    lock)
        lock_devices
        vgs="$(vgs | wc -l)"
        if [ "$vgs" -gt 0 ]; then
            vgchange -an >/dev/null
        fi
        ;;
esac
